# Inception

<!--
#groups
42

#languages
Bash
Docker

#frames and libs

-->

### This is an experimental guide! I am not really sure if what is wrote here is corerrect so, do not completly rely on this!!

## Table of Contents
1. [Introduction](#introduction)
    - [What is Docker?](#Docker)
    - [What is a Container?](#Containers)
    - [What is Docker Compose?](#Docker_Compose)
2. [Setup](#setup)
3. [Mandatory](#mandatory)
    - [Volumes](#volumes)
    - [Network](#network)
    - [MariaDB](#mariadb)
    - [Wordpress](#wordpress)
    - [Nginx](#nginx)
4. [End](#end)


<details>
<summary>Introduction</summary>

## Introduction
This project consists in having you set up a small infrastructure composed of different services under specific rules. The whole project has to be done in a virtual machine.

### <a name="Docker">What is Docker?</a>
<a href="https://docs.docker.com/get-started/overview/">Docker</a> enables you to separate your applications from your infrastructure so you can deliver software quickly. With Docker, you can manage your infrastructure in the same ways you manage your applications. By taking advantage of Docker’s methodologies for shipping, testing, and deploying code quickly, you can significantly reduce the delay between writing code and running it in production. This is possible thanks to the Docker's containers.

### <a name="Containers">What is a Container?</a>
A <a href="https://www.docker.com/resources/what-container/">Container</a> is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. It's different from a virtual machine because it's more lightweight than a VM.
The key differentiator between containers and virtual machines is that virtual machines virtualize an entire machine down to the hardware layers and containers only virtualize software layers above the operating system level.
<img src="container_vs_vm.png"/>
As you can see the VM loads every time the Guest OS, instead, Docker shares the same kernel with every container.

### <a name="Docker_Compose">What is Docker Compose?</a>
<a href="https://docs.docker.com/get-started/08_using_compose/">Docker Compose</a> is a tool that was developed to help define and share multi-container applications. With Compose, we can create a YAML file to define the services and with a single command, can spin everything up or tear it all down.

</details>

<details>
<summary>Setup</summary>

## Setup
The first thing we wanna do is to download the required software.
```
sudo apt install -y git docker docker.io docker-compose
```
And then restart docker to make sure that works fine.
```
sudo service docker restart
```

Now, the project folder structure should be something like this:
```
inception
├── Makefile
└── srcs
    ├── .env
    ├── docker-compose.yml
    └── requirements
        ├── mariadb
        │   ├── Dockerfile
        │   └── conf
        │       └── configure.sh
        ├── nginx
        │   ├── Dockerfile
        │   └── conf
        │       └── configure.sh
        └── wordpress
            ├── Dockerfile
            └── conf
                └── configure.sh
```

To finish the setup we can write a simple Makefile.
We start with the basic variables:
```
NAME = inception
SRC_DIR = srcs
ENV = $(SRC_DIR)/.env
YML = $(SRC_DIR)/docker-compose.yml
USER = ( your user name )
```
Then some command definitions:
```
DC		= sudo docker-compose
RM		= sudo rm -rf
MD		= sudo mkdir -p
```
Now we write some useful rules:
```
host:
	@ sudo echo "127.0.0.1 $(USER).42.fr" >> /etc/hosts

start:
	@ $(DC) --env-file $(ENV) -f $(YML) up

stop:
	@ $(DC) --env-file $(ENV) -f $(YML) down

.PHONY: start stop host
```
And at last the basic rules:
```
all: start

clean: stop
	@ sudo docker system prune -a -f

fclean: clean

re: fclean reload

reload:
	@ $(DC) --env-file $(ENV) -f $(YML) up --build
```

Final Result:
```
NAME = inception
SRC_DIR = srcs
ENV = $(SRC_DIR)/.env
YML = $(SRC_DIR)/docker-compose.yml
USER = ( your user name )

DC		= sudo docker-compose
RM		= sudo rm -rf
MD		= sudo mkdir -p


all: start

clean: stop
	@ sudo docker system prune -a -f

fclean: clean

re: fclean reload

reload:
	@ $(DC) --env-file $(ENV) -f $(YML) up --build

host:
	@ sudo echo "127.0.0.1 $(USER).42.fr" >> /etc/hosts

start:
	@ $(DC) --env-file $(ENV) -f $(YML) up

stop:
	@ $(DC) --env-file $(ENV) -f $(YML) down

.PHONY: start stop host all clean fclean re reload
```

</details>

## Mandatory

<details>
<summary>Volumes</summary>

## Volumes
<a href="https://docs.docker.com/storage/volumes/">Volumes</a> are the preferred mechanism for persisting data generated by and used by Docker containers. While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker.
 
 We must define two of them, one for the database and the othe one for the wordpress files in the docker-compose.yml we define them as "mariadb" for the database and "wordpress" for the wordpress files, and we put them in our data folder into the home directory.
 
 (USERNAME is your user)
 ./srcs/docker-compose.yml:
```
version: "3.5"

volumes:
  wordpress:
    name: wordpress
    driver: local
    driver_opts:
      device: /home/USERNAME/data/wordpress
      o: bind
      type: none

 mariadb:
    name: mariadb
    driver: local
    driver_opts:
      device: /home/USERNAME/data/mariadb
      o: bind
      type: none
```

To simplify things we can add some rules to maintain these directories and volumes.

```
VOLUMES	= $(shell sudo docker volume ls -q)

vol_clean:
	@ sudo docker volume rm $(VOLUMES)
	
dir_clean:
	@ $(RM) /home/$(USER)/data
	@ $(MD) /home/$(USER)/data
	@ $(MD) /home/$(USER)/data/mariadb
	@ $(MD) /home/$(USER)/data/wordpress
```

./Makefile:
```
NAME = inception
SRC_DIR = srcs
ENV = $(SRC_DIR)/.env
YML = $(SRC_DIR)/docker-compose.yml
USER = ( your user name )

DC		= sudo docker-compose
RM		= sudo rm -rf
MD		= sudo mkdir -p

VOLUMES	= $(shell sudo docker volume ls -q)


all: start

clean: stop
	@ sudo docker system prune -a -f

fclean: clean vol_clean dir_clean

re: fclean reload

reload:
	@ $(DC) --env-file $(ENV) -f $(YML) up --build

host:
	@ sudo echo "127.0.0.1 $(USER).42.fr" >> /etc/hosts

start:
	@ $(DC) --env-file $(ENV) -f $(YML) up

stop:
	@ $(DC) --env-file $(ENV) -f $(YML) down

vol_clean:
	@ sudo docker volume rm $(VOLUMES)

dir_clean:
	@ $(RM) /home/$(USER)/data
	@ $(MD) /home/$(USER)/data
	@ $(MD) /home/$(USER)/data/mariadb
	@ $(MD) /home/$(USER)/data/wordpress

.PHONY: start stop host all clean fclean re reload vol_clean dir_clean
```

</details>

<details>
<summary>Network</summary>

## Network
By default Compose sets up a single <a href="https://docs.docker.com/compose/networking/">network</a> for your app. Each container for a service joins the default network and is both reachable by other containers on that network, and discoverable by them at a hostname identical to the container name.
You can specify your own networks with the top-level networks key. This lets you create more complex topologies and specify custom network drivers and options. You can also use it to connect services to externally-created networks which aren’t managed by Compose.

So, to specify a custum network we can simply type into the docker-compose.yml:

```
networks:
  localhost:
    name: inet
```

./srcs/docker-compose.yml:
```
version: "3.5"

networks:
  localhost:
    name: inet

volumes:
  wordpress:
    name: wordpress
    driver: local
    driver_opts:
      device: /home/USERNAME/data/wordpress
      o: bind
      type: none

  mariadb:
    name: mariadb
    driver: local
    driver_opts:
      device: /home/USERNAME/data/mariadb
      o: bind
      type: none
```

</details>

<details>
<summary>MariaDB</summary>

## MariaDB

To add servicies in this project we need to define the "servicies" label into the docker-compose.yaml like:
```
services:
```

Under where we will put all the future sevicies, now we can add the service "mariadb" that will "always restart", it will be into the "localhost" network, and will be connected with the "mariadb" database.
```
  mariadb:  
    container_name: mariadb_debian
    build: ./requirements/mariadb
    volumes:
      - mariadb:/var/lib/mysql
    networks:
      - localhost
    image: mariadb
    restart: always
```
and then we can add the env variables to the env file and to the service environment:
.env (USERNAME is yours, and the two PASSWORD are your choice)
```
DB_HOST=mariadb
DB_NAME=wordpress
DB_USER=USERNAME
DB_PASSWORD=PASSWORD1
MYSQL_ROOT_PWD=PASSWORD2
```
docker-compose.yml
```
    environment:
      MYSQL_ROOT_PWD: ${MYSQL_ROOT_PWD}
      DB_NAME: ${DB_NAME}
      DB_USER: ${DB_USER}
      DB_PASSWORD: ${DB_PASSWORD}
```
Now we can pass at the mariadb's Dockerfile, where we start by loading the selected os image (debian in this case).
```
FROM debian:buster
```
Then we update the referencies and install the dependencies.
```
RUN apt-get update && apt-get install -y \
	mariadb-server
```
Now we copy the various configuration files in their spots.
```
COPY ./conf/50-server.cnf /etc/mysql/mariadb.conf.d/
COPY ./conf/createdb.sql /
COPY ./conf/configure.sh /configure.sh
```
And then we can use the "configure.sh" as an entrypoint:
```
CMD [ "sh", "/configure.sh" ]
```

./srcs/requirements/mariadb/Dockerfile
```
FROM debian:buster

RUN apt-get update && apt-get install -y \
	mariadb-server


COPY ./conf/50-server.cnf /etc/mysql/mariadb.conf.d/
COPY ./conf/createdb.sql /
COPY ./conf/configure.sh /configure.sh

CMD [ "sh", "/configure.sh" ]
```

So, the "50-server.cnf" is the default file that is present with mariadb but with the bind address commented or removed.
(this line):
```
bind-address            = 0.0.0.0
```
And the query cache limit as the same of the previous:
```
#query_cache_limit      = 1M
```

Next we have the "createdb.sql" that only contains some instruction to create the database.
At the first line we create the database.
```
CREATE DATABASE ${DB_NAME};
```
We now can add the user and his password.
```
CREATE USER '${DB_USER}'@'%' IDENTIFIED BY '${DB_PASSWORD}';
```
Then we grant him the privileges.
```
GRANT ALL PRIVILEGES ON ${DB_NAME}.* TO '${DB_USER}'@'%';
```
And we flush them.
```
FLUSH PRIVILEGES;
```
At the end we now can update the root user:
```
UPDATE mysql.user
    SET authentication_string = PASSWORD('${MYSQL_ROOT_PWD}'), password_expired = 'N'
    WHERE User = 'root' AND Host = 'localhost';
FLUSH PRIVILEGES;
```

./srcs/requirements/mariadb/conf/createdb.sql
```
CREATE DATABASE ${DB_NAME};
CREATE USER '${DB_USER}'@'%' IDENTIFIED BY '${DB_PASSWORD}';
GRANT ALL PRIVILEGES ON ${DB_NAME}.* TO '${DB_USER}'@'%';
FLUSH PRIVILEGES;

UPDATE mysql.user
    SET authentication_string = PASSWORD('${MYSQL_ROOT_PWD}'), password_expired = 'N'
    WHERE User = 'root' AND Host = 'localhost';
FLUSH PRIVILEGES;
```

Now the only file missing is the "configure.sh", where we initialy check if the "createdb.sql" exists, so we can create the database, by replacing the env variables and setting the right permissions on files and then really creating the database:
```
if [ -f /createdb.sql ]; then
	# Set env
	sed -i -e "s/\${DB_USER}/${DB_USER}/g" /createdb.sql;
	sed -i -e "s/\${DB_PASSWORD}/${DB_PASSWORD}/g" /createdb.sql;
	sed -i -e "s/\${DB_NAME}/${DB_NAME}/g" /createdb.sql;
	sed -i -e "s/\${MYSQL_ROOT_PWD}/${MYSQL_ROOT_PWD}/g" /createdb.sql;

	# Set no writing permissions
	chmod 0444 /etc/mysql/mariadb.conf.d/50-server.cnf;

	# Create the Database
	service mysql start 2> /dev/null 1> /dev/nul \
	&& mysql < /createdb.sql 2> /dev/null 1> /dev/nul \
	&& service mysql stop 2> /dev/null 1> /dev/null;

	# Remove the database creation file
	rm -f /createdb.sql;
fi
```

In the end we can put the real entrypoint:
```
/usr/bin/mysqld_safe;
```

./srcs/requirements/mariadb/conf/configure.sh
```
#!/bin/bash

if [ -f /createdb.sql ]; then
	# Set env
	sed -i -e "s/\${DB_USER}/${DB_USER}/g" /createdb.sql;
	sed -i -e "s/\${DB_PASSWORD}/${DB_PASSWORD}/g" /createdb.sql;
	sed -i -e "s/\${DB_NAME}/${DB_NAME}/g" /createdb.sql;
	sed -i -e "s/\${MYSQL_ROOT_PWD}/${MYSQL_ROOT_PWD}/g" /createdb.sql;

	# Set no writing permissions
	chmod 0444 /etc/mysql/mariadb.conf.d/50-server.cnf;

	# Create the Database
	service mysql start 2> /dev/null 1> /dev/nul \
	&& mysql < /createdb.sql 2> /dev/null 1> /dev/nul \
	&& service mysql stop 2> /dev/null 1> /dev/null;

	# Remove the database creation file
	rm -f /createdb.sql;
fi

# Entrypoint
/usr/bin/mysqld_safe;
```

</details>

<details>
<summary>Wordpress</summary>

## Wordpress

Into the services we add the wordpress image that depends on mariadb, should restart when crashing, connected to the wordpress volume and the network.
```
  wordpress:
    depends_on:
      - mariadb
    container_name: wordpress_debian
    build: ./requirements/wordpress
    image: wordpress
    volumes:
      - wordpress:/var/www/wordpress
    networks:
      - localhost
    restart: always
```
And then add the environment for the database connection:
```
    environment:
      DB_HOST: ${DB_HOST}
      DB_NAME: ${DB_NAME}
      DB_USER: ${DB_USER}
      DB_PASSWORD: ${DB_PASSWORD}
```

Into the Dockerfile we start with putting at the first line the os image that we want (i will use debian):
```
FROM debian:buster
```

Then we want to update our referencies and install the dependencies:
```
RUN apt-get update && apt-get install -y \
	php7.3 \
	php-mysqli \
	php-fpm \
	mariadb-client
```

Then we can copy the custom fpm configuration:
```
COPY ./conf/www.conf /etc/php/7.3/fpm/pool.d
```

./srcs/requirements/wordpress/conf/www.conf:
```
[www]
user = www-data
group = www-data
listen = wordpress:9000
pm = dynamic
pm.max_children = 30
pm.start_servers = 3
pm.min_spare_servers = 3
pm.max_spare_servers = 10
pm.max_requests = 1000
pm.status_path = /status
clear_env = no
```

Then we can pull the wordpress files from his site (these are italian ones), and then remove the "wp-config-sample.php":
```
ADD https://it.wordpress.org/wordpress-5.7.2-it_IT.tar.gz /var/www/
RUN cd /var/www && tar -xzvf wordpress-5.7.2-it_IT.tar.gz
RUN rm -f /var/www/wordpress-5.7.2-it_IT.tar.gz
RUN rm -f /var/www/wordpress/wp-config-sample.php
```

Now we can actualy copy the custom wordpress config file, and the configure script and than using it as entrypoint, and we create a file thet we will use as a creation-fase-switch.
```
COPY ./conf/wp-config.php ./var/www/wordpress/
COPY ./conf/configure.sh /configure.sh

RUN touch /tmp/switch.tmp

CMD [ "sh", "/configure.sh" ]
```

./srcs/requirements/wordpress/Dockerfile:
```
FROM debian:buster

RUN apt-get update && apt-get install -y \
	php7.3 \
	php-mysqli \
	php-fpm \
	mariadb-client

COPY ./conf/www.conf /etc/php/7.3/fpm/pool.d

ADD https://it.wordpress.org/wordpress-5.7.2-it_IT.tar.gz /var/www/
RUN cd /var/www && tar -xzvf wordpress-5.7.2-it_IT.tar.gz
RUN rm -f /var/www/wordpress-5.7.2-it_IT.tar.gz
RUN rm -f /var/www/wordpress/wp-config-sample.php

COPY ./conf/wp-config.php ./var/www/wordpress/
COPY ./conf/configure.sh /configure.sh

RUN touch /tmp/switch.tmp

CMD [ "sh", "/configure.sh" ]
```

Into the custom "wp-config.php" we can put the same stuff of the sample one, but we can modify the define statemets at the beginnig with env variable that we will pass in the congiure.sh.
```
define( 'DB_NAME', '${DB_NAME}' );
define( 'DB_USER', '${DB_USER}' );
define( 'DB_PASSWORD', '${DB_PASSWORD}' );
define( 'DB_HOST', '${DB_HOST}' );
```

In the config file we start by defining the only installation stuff, witch are the env variables sobstituition, and the creation of the php folder into the run one, and then we can remove the temp switch file.
```
if [ -f /tmp/switch.tmp ]; then
	# Set Env
	sed -i -e "s/\${DB_NAME}/${DB_NAME}/g" /var/www/wordpress/wp-config.php;
	sed -i -e "s/\${DB_USER}/${DB_USER}/g" /var/www/wordpress/wp-config.php;
	sed -i -e "s/\${DB_PASSWORD}/${DB_PASSWORD}/g" /var/www/wordpress/wp-config.php;
	sed -i -e "s/\${DB_HOST}/${DB_HOST}/g" /var/www/wordpress/wp-config.php;

	# Create the php folder
	mkdir -p ./run/php/;

	# Remove the switch
	rm -f /tmp/switch.tmp;

fi
```

And we finish with the actual entrypoint:
```
/usr/sbin/php-fpm7.3 -F;
```

./srcs/requirements/wordpress/conf/configure.sh:
```
#!/bin/bash

if [ -f /tmp/switch.tmp ]; then
	# Set Env
	sed -i -e "s/\${DB_NAME}/${DB_NAME}/g" /var/www/wordpress/wp-config.php;
	sed -i -e "s/\${DB_USER}/${DB_USER}/g" /var/www/wordpress/wp-config.php;
	sed -i -e "s/\${DB_PASSWORD}/${DB_PASSWORD}/g" /var/www/wordpress/wp-config.php;
	sed -i -e "s/\${DB_HOST}/${DB_HOST}/g" /var/www/wordpress/wp-config.php;

	# Create the php folder
	mkdir -p ./run/php/;

	# Remove the switch
	rm -f /tmp/switch.tmp;

fi

# Entrypoint
/usr/sbin/php-fpm7.3 -F;
```

</details>

<details>
<summary>Nginx</summary>

## Nginx

Into the services we can now add nginx that depends on wordpress, should restart when crashing, connected to the wordpress volume and the network, with the port 443 exposed for connections.
```
  nginx:
    depends_on:
      - wordpress
    container_name: nginx_debian
    build: ./requirements/nginx
    image: nginx
    ports:
      - "443:443"
    volumes:
      - wordpress:/var/www/wordpress
    networks:
      - localhost
    restart: always
```

Now we can add the env to the ".env" file:
```
NGINX_C=COUNTRYWHEREYOUARE
NGINX_ST=CITYWHEREYOUARE
NGINX_L=CITYWHEREYOUARE
NGINX_O=42
NGINX_OU=USERNAME
NGINX_CN=USERNAME.42.fr
NGINX_EMAIL_ADDRESS=YOURMAIL
```

Then we can add the environment for the ssl key creation and then pass into the nginx dockerfile.
```
    environment:
      NGINX_C: ${NGINX_C}
      NGINX_ST: ${NGINX_ST}
      NGINX_L: ${NGINX_L}
      NGINX_O: ${NGINX_O}
      NGINX_OU: ${NGINX_OU}
      NGINX_CN: ${NGINX_CN}
      NGINX_EMAIL_ADDRESS: ${NGINX_EMAIL_ADDRESS}
```

The first thing we want to do is gettign up the container, so, in the Docker file we put at the first line the os image that we want (i will use debian):
```
FROM debian:buster
```

Then we want to update our referencies and install the dependencies:
```
RUN apt-get update && apt-get install -y \
	nginx \
	openssl
```

now we need to copy the configuration files, but first, to configure Nginx we need to create the ssl key like in this tutorials:
https://linuxize.com/post/creating-a-self-signed-ssl-certificate/
https://deliciousbrains.com/ssl-certificate-authority-for-local-https-development/

And then write the default configuration like in this article:
https://medium.com/@jgefroh/a-guide-to-using-nginx-for-static-websites-d96a9d034940

In short we obtain a "default" file like: (where USERNAME is our user)

./srcs/requirements/nginx/conf/default:
```
server {
    listen 443 ssl;
    listen [::]:443 ssl;

    server_name USERNAME.42.fr;

    ssl_certificate_key /etc/ssl/private/nginx.key;
    ssl_certificate /etc/ssl/certs/nginx.crt;
    ssl_protocols TLSv1.2 TLSv1.3;
    
    index index.php;
    root /var/www/wordpress;

    location / {
        try_files $uri $uri/ /index.php$is_args$args;
    }
    location ~ [^/]\.php(/|$) { 
            try_files $uri =404;
            fastcgi_split_path_info ^(.+\.php)(/.+)$;
            fastcgi_pass wordpress:9000;
            fastcgi_index index.php;
            include fastcgi_params;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
            fastcgi_param PATH_INFO $fastcgi_path_info;
        }
}
```

and in the "Dockerfile" we can add:
```
COPY ./conf/default etc/nginx/sites-enabled/default
COPY ./conf/configure.sh /

RUN touch /tmp/switch.tmp

CMD [ "sh", "/configure.sh" ]
```
Where we copy the default config into his folder, copy the config file that we will use as entrypoint and we create a file thet we will use as a creation-fase-switch.

./srcs/requirements/nginx/Dockerfile:
```
FROM debian:buster

RUN apt-get update && apt-get install -y \
	nginx \
	openssl

COPY ./conf/default etc/nginx/sites-enabled/default
COPY ./conf/configure.sh /

RUN touch /tmp/switch.tmp

CMD [ "sh", "/configure.sh" ]
```

Into the "configure.sh" file we can put at the beginning the ssl key creation in an if statement where we check if the switch file exists, and after the key creation we delete the file.
```
if [ -f /tmp/switch.tmp ]; then

	# Create the ssl key
	openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
		-keyout /etc/ssl/private/nginx.key \
		-out /etc/ssl/certs/nginx.crt \
		-subj "/C=${NGINX_C}/ST=${NGINX_ST}/L=${NGINX_L}/O=${NGINX_O}/OU=${NGINX_OU}/CN=${NGINX_CN}/emailAddress=${NGINX_EMAIL_ADDRESS}";
	
	# Remove the switch
	rm -f /tmp/switch.tmp;

fi
```

At the end of the file we can put our real entrypoint like this:
```
nginx -g "daemon off;";
```

./srcs/requirements/nginx/conf/configure.sh:
```
#!/bin/bash

if [ -f /tmp/switch.tmp ]; then

	# Create the ssl key
	openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
		-keyout /etc/ssl/private/nginx.key \
		-out /etc/ssl/certs/nginx.crt \
		-subj "/C=${NGINX_C}/ST=${NGINX_ST}/L=${NGINX_L}/O=${NGINX_O}/OU=${NGINX_OU}/CN=${NGINX_CN}/emailAddress=${NGINX_EMAIL_ADDRESS}";
	
	# Remove the switch
	rm -f /tmp/switch.tmp;

fi

nginx -g "daemon off;";
```

</details>

## End
Now running "make" and after typing the root password we should see the containers's creation process, after the deploy we can go to "https://localhost" or "localhost:443" to access the site where we should see the wordpress configuration page

## Thanks for the attention
I hope that this weird tutorial can be useful for your projects.



